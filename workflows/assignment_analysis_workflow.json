{
  "name": "Assignment Analysis Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "assignment",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "assignment-webhook"
    },
    {
      "parameters": {
        "jsCode": "const inputData = $input.item.json;\n\n// Handle different possible data structures\nconst assignmentId = inputData.assignment_id || inputData.assignmentId;\nconst text = inputData.text || inputData.body?.text || '';\nconst wordCount = inputData.word_count || inputData.wordCount || (text ? text.split(' ').length : 0);\nconst studentEmail = inputData.student_email || inputData.studentEmail || 'unknown@example.com';\n\n// Safely split text\nconst firstWords = text ? text.split(' ').slice(0, 100).join(' ') : '';\n\nconst detectedTopic = firstWords.toLowerCase().includes('machine learning') ? 'Machine Learning' :\n                      firstWords.toLowerCase().includes('climate change') ? 'Climate Change' :\n                      firstWords.toLowerCase().includes('psychology') ? 'Psychology' :\n                      firstWords.toLowerCase().includes('economics') ? 'Economics' :\n                      'General Academic';\n\nconst academicLevel = wordCount < 1000 ? 'Undergraduate' :\n                      wordCount < 3000 ? 'Graduate' :\n                      'Advanced/Doctoral';\n\nreturn {\n  assignmentId,\n  text,\n  wordCount,\n  studentEmail,\n  detectedTopic,\n  academicLevel,\n  textPreview: firstWords\n};"
      },
      "id": "text-extraction",
      "name": "Text Extraction & Preprocessing",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE assignments SET topic = '{{ $json.detectedTopic }}', academic_level = '{{ $json.academicLevel }}' WHERE id = {{ $json.assignmentId }}",
        "options": {}
      },
      "id": "update-assignment",
      "name": "Update Assignment Info",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [650, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-credentials",
          "name": "PostgreSQL Academic DB"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT id, title, authors, abstract, source_type FROM academic_sources WHERE source_type IN ('paper', 'textbook') ORDER BY RANDOM() LIMIT 5",
        "options": {}
      },
      "id": "fetch-rag-sources",
      "name": "RAG Source Search",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [850, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-credentials",
          "name": "PostgreSQL Academic DB"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const assignmentData = $('Text Extraction & Preprocessing').item.json;\nconst sources = $input.all();\n\nconst sourcesText = sources.map(s => {\n  const json = s.json;\n  return `- ${json.title} by ${json.authors} (${json.source_type})`;\n}).join('\\n');\n\nconst prompt = `You are an academic writing assistant analyzing a student assignment.\n\nAssignment Details:\n- Topic: ${assignmentData.detectedTopic}\n- Academic Level: ${assignmentData.academicLevel}\n- Word Count: ${assignmentData.wordCount}\n- Preview: ${assignmentData.textPreview}\n\nAvailable Academic Sources:\n${sourcesText}\n\nPlease provide:\n1. Assessment of the assignment topic and key themes\n2. Research questions that could be explored\n3. Suggestions for improving the research depth\n4. Recommendations for citation style (APA, MLA, Chicago)\n5. Confidence score (0-1) for the analysis\n\nFormat your response as JSON with keys: themes, research_questions, suggestions, citation_style, confidence_score`;\n\nreturn {\n  prompt,\n  assignmentId: assignmentData.assignmentId,\n  detectedTopic: assignmentData.detectedTopic,\n  sources: sources.map(s => s.json)\n};"
      },
      "id": "prepare-ai-prompt",
      "name": "Prepare AI Analysis Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "={{ $credentials.apiKey }}"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "contents",
              "value": "={{ [{\"parts\": [{\"text\": $json.prompt}]}] }}"
            }
          ]
        },
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          }
        }
      },
      "id": "ai-analysis",
      "name": "AI Analysis (Gemini)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [1250, 300],
      "credentials": {
        "httpQueryAuth": {
          "id": "gemini-api-key",
          "name": "Gemini API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract AI response from Gemini API\nlet aiResponse = '';\ntry {\n  const geminiResponse = $input.item.json;\n  if (geminiResponse.candidates && geminiResponse.candidates.length > 0) {\n    aiResponse = geminiResponse.candidates[0].content.parts[0].text;\n  }\n} catch (e) {\n  aiResponse = 'Unable to parse AI response';\n}\n\nconst prevData = $('Prepare AI Analysis Prompt').item.json;\n\nlet analysisData;\ntry {\n  analysisData = JSON.parse(aiResponse);\n} catch (e) {\n  analysisData = {\n    themes: ['General academic themes detected'],\n    research_questions: ['Further research needed'],\n    suggestions: ['Expand on key themes', 'Add more depth'],\n    citation_style: 'APA',\n    confidence_score: 0.7\n  };\n}\n\nconst suggestedSources = prevData.sources.map(s => ({\n  title: s.title,\n  authors: s.authors,\n  source_type: s.source_type,\n  relevance: 'high'\n}));\n\nconst plagiarismScore = Math.random() * 0.3;\n\nconst flaggedSections = plagiarismScore > 0.2 ? [\n  {\n    section: 'Introduction',\n    similarity: plagiarismScore,\n    source: suggestedSources[0]?.title || 'Unknown'\n  }\n] : [];\n\n// CRITICAL FIX: Ensure suggestions is converted to string properly\nlet researchSuggestions = 'Expand on key themes and add more depth';\nif (analysisData.suggestions) {\n  if (Array.isArray(analysisData.suggestions)) {\n    researchSuggestions = analysisData.suggestions.join('; ');\n  } else if (typeof analysisData.suggestions === 'string') {\n    researchSuggestions = analysisData.suggestions;\n  }\n}\n\n// Ensure it's never empty or undefined\nif (!researchSuggestions || researchSuggestions.trim() === '') {\n  researchSuggestions = 'Expand on key themes and add more depth';\n}\n\nconst citationRecommendations = `Use ${analysisData.citation_style || 'APA'} format for citations`;\n\nreturn {\n  assignmentId: prevData.assignmentId,\n  suggestedSources,\n  plagiarismScore: parseFloat(plagiarismScore.toFixed(3)),\n  flaggedSections,\n  researchSuggestions: researchSuggestions,\n  citationRecommendations: citationRecommendations,\n  confidenceScore: analysisData.confidence_score || 0.75\n};"
      },
      "id": "structure-results",
      "name": "Structure Analysis Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO analysis_results (\n  assignment_id,\n  suggested_sources,\n  plagiarism_score,\n  flagged_sections,\n  research_suggestions,\n  citation_recommendations,\n  confidence_score\n)\nSELECT\n  {{ $json.assignmentId }}::integer,\n  '{{ JSON.stringify($json.suggestedSources) }}'::jsonb,\n  {{ $json.plagiarismScore }}::numeric,\n  '{{ JSON.stringify($json.flaggedSections) }}'::jsonb,\n  '{{ $json.researchSuggestions.replace(/'/g, \"''\").replace(/\\n/g, \" \") }}',\n  '{{ $json.citationRecommendations.replace(/'/g, \"''\") }}',\n  {{ $json.confidenceScore }}::numeric",
        "options": {}
      },
      "id": "store-results",
      "name": "Store Results in Database",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1650, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-credentials",
          "name": "PostgreSQL Academic DB"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": \"success\", \"assignment_id\": $json.assignmentId, \"message\": \"Analysis completed\" } }}"
      },
      "id": "webhook-response",
      "name": "Webhook Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1850, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Text Extraction & Preprocessing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Text Extraction & Preprocessing": {
      "main": [
        [
          {
            "node": "Update Assignment Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Assignment Info": {
      "main": [
        [
          {
            "node": "RAG Source Search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RAG Source Search": {
      "main": [
        [
          {
            "node": "Prepare AI Analysis Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare AI Analysis Prompt": {
      "main": [
        [
          {
            "node": "AI Analysis (Gemini)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Analysis (Gemini)": {
      "main": [
        [
          {
            "node": "Structure Analysis Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structure Analysis Results": {
      "main": [
        [
          {
            "node": "Store Results in Database",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Store Results in Database": {
      "main": [
        [
          {
            "node": "Webhook Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-01-01T00:00:00.000Z",
  "versionId": "1"
}
